//
//
//  Generated by StarUML(tm) C# Add-In
//
//  @ Project : SFML Framework
//  @ File Name : Collider.cs
//  @ Date : 13/09/2016
//  @ Author : Daybson B. S. Paisante <daybson.paisante@outlook.com>
//
//

using SFML.Graphics;
using SFML.Window;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using SFML.System;

public class RectCollider : Component, ICollision
{
    #region Fields

    protected RectangleShape collider;
    public IMove imove;
    public IMove IMove { get { return imove; } set { imove = value; } }

    #endregion


    #region Public

    /// <summary>
    /// Checa se uma colisão aconteceu entre o collider e algum outro ICollision, preenchendo as informações da colisão caso tenha ocorrido
    /// </summary>
    /// <param name="obstacle">Obstáculo contra o qual a colisão é checada</param>
    /// <param name="hitInfo">Informações da colisão</param>
    /// <returns>True se aconteceu a colisão, False se não aconteceu</returns>
    public bool CheckCollision(ICollision obstacle, out CollisionInfo hitInfo)
    {
        hitInfo = null;

        //cache do shape do obstáculo
        var obstacleShape = (RectangleShape)obstacle.GetShape();

        //cache dos bounds dos shapes de colisão
        var myLeft = this.collider.Position.X;
        var myRight = this.collider.Position.X + this.collider.Size.X;
        var myUpper = this.collider.Position.Y;
        var myBottom = this.collider.Position.Y + this.collider.Size.Y;

        var oLeft = obstacleShape.Position.X;
        var oRight = obstacleShape.Position.X + obstacleShape.Size.X;
        var oUpper = obstacleShape.Position.Y;
        var oBottom = obstacleShape.Position.Y + obstacleShape.Size.Y;

        //teste de colisão        
        if (!((myRight <= oLeft) || (myLeft >= oRight) || (myBottom <= oUpper) || (myUpper >= oBottom)))
        {
            float dx = 0;
            float dy = 0;

            //indentifica a direção do movimento atual e calcula a devida profundidade da colisão naquele sentido
            switch (this.imove.direction)
            {
                case Mover.Direction.Down:
                    dy = myBottom - oUpper;
                    break;
                case Mover.Direction.Up:
                    dy = myUpper - oBottom;
                    break;
                case Mover.Direction.Left:
                    dx = myLeft - oRight;
                    break;
                case Mover.Direction.Right:
                    dx = myRight - oLeft;
                    break;
                default:
                    dx = 0;
                    dy = 0;
                    break;
            }

            hitInfo = new CollisionInfo(new Vector2f(dx, dy), this.imove.direction);
            this.collider.OutlineColor = Color.Red;
            return true;
        }
        else
        {
            this.collider.OutlineColor = Color.Magenta;
            return false;
        }
    }

    public Shape GetShape()
    {
        return this.collider;
    }

    /// <summary>
    /// Cria um RectCollider para determinado sprite
    /// </summary>
    /// <param name="sprite">Sprite cujo bounds será usado para criar um RectCollider</param>
    public void SetSprite(Sprite sprite)
    {
        this.collider = new RectangleShape(new Vector2f(sprite.GetGlobalBounds().Width, sprite.GetGlobalBounds().Height));
        this.collider.OutlineColor = Color.Magenta;
        this.collider.OutlineThickness = 1;
        this.collider.FillColor = Color.Transparent;
    }

    /// <summary>
    /// Resolve a colisão corrigindo a posição de acordo com a direção e quantidade de penetração no obstáculo
    /// </summary>
    /// <param name="hitInfo">Informação da colsião</param>
    public void SolveCollision(CollisionInfo hitInfo)
    {
        var mover = this.root.GetComponent<Mover>();
        if (mover != null)
        {
            Console.WriteLine("Depth collision:" + hitInfo.ToString());

            //determina a direção da colisão e atualiza a posição de acordo com o plano cartesiano
            switch (mover.direction)
            {
                case Mover.Direction.Left:
                    //se move para direita (-), soma na posição a profundidade da colisão em X
                    mover.Position += new Vector2f(hitInfo.Depth.X, 0);
                    break;
                case Mover.Direction.Right:
                    //se move para direita (+), reduz na posição a profundidade da colisão em X
                    mover.Position -= new Vector2f(hitInfo.Depth.X, 0);
                    break;
                case Mover.Direction.Up:
                    //se move para cima (-), soma na posição a profundidade da colisão em Y
                    mover.Position += new Vector2f(0, hitInfo.Depth.Y);
                    break;
                case Mover.Direction.Down:
                    //se move para baixo (+), reduz na posição a profundidade da colisão em Y
                    mover.Position -= new Vector2f(0, hitInfo.Depth.Y);
                    break;
            }
        }
        else
            Console.WriteLine("Uma referência de componente IMover é necessário para resolver a colsião");
    }

    public override void Update(float deltaTime)
    {
        if (this.IMove != null)
            this.collider.Position = this.IMove.Position;
        else
            Console.WriteLine("Renderer component requires an IMove reference's object to update position");
    }

    #endregion
}
